"use strict";(self.webpackChunkapp_DSLearnerNotes=self.webpackChunkapp_DSLearnerNotes||[]).push([[384],{384:(c,a,s)=>{s.r(a),s.d(a,{PythonModule:()=>i});var u=s(808),l=s(895),n=s(223);const r=[{path:"",children:[{path:"data-types",component:(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(o){return new(o||e)},e.\u0275cmp=n.Xpm({type:e,selectors:[["app-data-types"]],decls:6,vars:0,template:function(o,p){1&o&&(n.TgZ(0,"h2"),n._uU(1,"Data Types in Python:"),n.qZA(),n.TgZ(2,"p"),n._uU(3," Todos los datos almacenados en Python son objetos. Estos objetos tienen una identidad, un tipo y un valor. El tipo y la identidad de estos no puede cambiar, pero en algunos, su valor s\xed y as\xed se pueden clasificar los datos en mutables e inmutables.\nDatos num\xe9ricos: "),n._UZ(4,"br"),n._uU(5,"\nPython distingue n\xfameros entre enteros, flotantes y complejos. Entre los enteros tenemos:\n-\tEnteros (int):\n-\tBooleanos (bool):\nLos n\xfameros flotantes son tambi\xe9n llamados n\xfameros reales:\n-\tReal (float):\nEn contraparte a los n\xfameros imaginarios o complejos:\n-\tComplejos (complex): Datos secuenciales:\nEstos almacenan un conjunto de elementos indexados. Se puede conocer la cantidad de elementos de un dato secuencial usando la funci\xf3n len().\nLos siguientes tipos de datos son inmutables, es decir que una vez han sido creados, no pueden cambiar sus elementos:\n-\tString (str)\n-\tTuplas (tuple)\n-\tBytes (byte)\nLos siguientes tipos, por su parte, son mutables:\n-\tListas (list)\n-\tArreglos de bytes (bytearray)\nSe puede acceder a los elementos de todos estos datos secuenciales. Estos elementos est\xe1n numerados desde 0 hasta n-1, donde n es la cantidad de elementos. Con esta numeraci\xf3n podemos acceder a los elementos usando []. Por ejemplo, si queremos acceder al primer elemento del dato secuencia a, accedemos a \xe9l usando a[0].\nLos elementos no tienen numeraci\xf3n negativa, sin embargo, al intentar acceder a un elemento indic\xe1ndolo como negativo, Python numerar\xe1 en sentido inverso. As\xed, el elemento -1 ser\xe1 el \xfaltimo elemento.\nTambi\xe9n se puede tomar una secci\xf3n de datos de la forma a[i:j]. Esto toma todos los elementos desde i, pero no alcanza a tomar el elemento j. Algunas secuencias permiten tomar elementos con un paso intermedio entre ellos de la forma a[i:j:k], donde k es el paso. Por ejemplo, se pueden tomar los elementos pares de 0 a 10 de la esta forma: a[0:10:2]. Esto tomar\xe1 a los elementos 0, 2, 4, 6 y 8. Conjuntos:\nEstos contienen elementos que son \xfanicos entre ellos. Estos elementos no tienen un orden en particular y por esto no es posible acceder a alguno de ellos indicando su numeraci\xf3n. Con ellos se pueden realizar operaciones matem\xe1ticas, como lo es la uni\xf3n, la intersecci\xf3n, diferencia y diferencia sim\xe9trica. Para a\xf1adir un elemento a un conjunto mutable se usa el m\xe9todo add().\n-\tSets (set)\n-\tSets congelados (frozenset) Mappings\nEstos representan un conjunto de datos con \xedndice arbitrario.\n-\tDictionary (dict) "),n.qZA())},styles:[""]}),e})()},{path:"**",redirectTo:"data-types"}]}];let d=(()=>{class e{}return e.\u0275fac=function(o){return new(o||e)},e.\u0275mod=n.oAB({type:e}),e.\u0275inj=n.cJS({imports:[[l.Bz.forChild(r)],l.Bz]}),e})(),i=(()=>{class e{}return e.\u0275fac=function(o){return new(o||e)},e.\u0275mod=n.oAB({type:e}),e.\u0275inj=n.cJS({imports:[[u.ez,d]]}),e})()}}]);